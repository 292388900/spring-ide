<!DOCTYPE html>
<meta charset="utf-8">
<style>
.link {
	stroke: #ccc;
}

.node text {
	pointer-events: none;
	font: 10px sans-serif;
}
</style>
<link rel="stylesheet" type="text/css" href="css/app.css" />
<body>
	<script src="http://d3js.org/d3.v3.js"></script>
	<script>
		var width = 960, height = 500, colors = d3.scale.category10();

		var svg = d3.select("body").append("svg").attr("width", width).attr("height", height);

		var force = d3.layout.force().gravity(.05).linkDistance(100).charge(-200).size([ width, height ]);

		// mouse event vars
		var selected_node = null, selected_link = null, mousedown_link = null, mousedown_node = null, mouseup_node = null;

		function resetMouseVars() {
			mousedown_node = null;
			mouseup_node = null;
			mousedown_link = null;
		}

		// handles to link and node element groups
		var path = svg.append('svg:g').selectAll('path'), circle = svg.append('svg:g').selectAll('g');
		d3.json("data2.json", function(error, json) {
			force.nodes(json.nodes).links(json.links).start();

			svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr(
					'refX', 6).attr('markerWidth', 10).attr('markerHeight', 10).attr('orient', 'auto').append(
					'svg:path').attr('d', 'M0,-5L10,0L0,5').attr('fill', '#000');

			svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr(
					'refX', 4).attr('markerWidth', 10).attr('markerHeight', 10).attr('orient', 'auto').append(
					'svg:path').attr('d', 'M10,-5L0,0L10,5').attr('fill', '#000');

			var link = svg.selectAll(".link").data(json.links).enter().append("line").attr("class", "link").classed(
					'selected', function(d) {
						return d === selected_link;
					}).style('marker-start', function(d) {
				return d.left ? 'url(#start-arrow)' : '';
			}).style('marker-end', function(d) {
				return d.right ? 'url(#end-arrow)' : '';
			}).on('mousedown', function(d) {
				if (d3.event.ctrlKey)
					return;

				// select link
				mousedown_link = d;
				if (mousedown_link === selected_link)
					selected_link = null;
				else
					selected_link = mousedown_link;
				selected_node = null;
				restart();
			});

			var node = svg.selectAll(".node").data(json.nodes).enter().append("g").attr("class", "node").call(
					force.drag);

			node.append('svg:circle').attr('class', 'node').attr('r', 4).attr('x', 10).attr('y', -15)
					.style('fill', function(d) {
						return (d === selected_node) ? d3.rgb(colors(d.id)).brighter().toString() : colors(d.id);
					}).style('stroke', function(d) {
						return d3.rgb(colors(d.id)).darker().toString();
					}).classed('reflexive', function(d) {
						return d.reflexive;
					}).on('mouseover', function(d) {
						if (!mousedown_node || d === mousedown_node)
							return;
						// enlarge target node
						d3.select(this).attr('transform', 'scale(1.1)');
					}).on('mouseout', function(d) {
						if (!mousedown_node || d === mousedown_node)
							return;
						// unenlarge target node
						d3.select(this).attr('transform', '');
					}).on(
							'mousedown',
							function(d) {
								if (d3.event.ctrlKey)
									return;

								// select node
								mousedown_node = d;
								if (mousedown_node === selected_node)
									selected_node = null;
								else
									selected_node = mousedown_node;
								selected_link = null;

								// reposition drag line
								drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr(
										'd',
										'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ','
												+ mousedown_node.y);

								restart();
							}).on('mouseup', function(d) {
						if (!mousedown_node)
							return;

						// needed by FF
						drag_line.classed('hidden', true).style('marker-end', '');

						// check for drag-to-self
						mouseup_node = d;
						if (mouseup_node === mousedown_node) {
							resetMouseVars();
							return;
						}

						// unenlarge target node
						d3.select(this).attr('transform', '');

						// add link to graph (update if exists)
						// NB: links are strictly source < target; arrows separately specified by booleans
						var source, target, direction;
						if (mousedown_node.id < mouseup_node.id) {
							source = mousedown_node;
							target = mouseup_node;
							direction = 'right';
						} else {
							source = mouseup_node;
							target = mousedown_node;
							direction = 'left';
						}

						var link;
						link = links.filter(function(l) {
							return (l.source === source && l.target === target);
						})[0];

						if (link) {
							link[direction] = true;
						} else {
							link = {
								source : source,
								target : target,
								left : false,
								right : false
							};
							link[direction] = true;
							links.push(link);
						}

						// select new link
						selected_link = link;
						selected_node = null;
						restart();
					});

			node.append("text").attr("dx", 12).attr("dy", ".02em")
		    .style('fill', function(d) { return (d === selected_node) ? d3.rgb(colors(d.id)).brighter().toString() : colors(d.id); })
			.text(function(d) {
				return d.name
			});

			force.on("tick", function() {
				link.attr("x1", function(d) {
					return d.source.x;
				}).attr("y1", function(d) {
					return d.source.y;
				}).attr("x2", function(d) {
					return d.target.x;
				}).attr("y2", function(d) {
					return d.target.y;
				});

				node.attr("transform", function(d) {
					return "translate(" + d.x + "," + d.y + ")";
				});
			});

		});
	</script>